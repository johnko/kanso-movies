/*
 *This shim is from the original CouchApp
 */
module.exports = {
    "README": "## CouchApp - more than just a filesystem mapper\n\nThis is where documentation will go for the client and server JavaScript parts of CouchApp.",
    "metadata": {
        "name": "couchapp",
        "description": "official couchapp vendor"
    },
    "docs": {
        "account": "# Docs for the account widget\n\nYou should use this widget in any CouchApp that allows users to login or signup.\n\nIt is easy to install. To use the account widget, just define a `div` in your page and use [CouchApp](#/topic/couchapp) to load it from the design document and [Evently](#/topic/evently) to apply it to the page.\n\nHere's the most basic usage:\n\n    $.couch.app(function(app){\n      $(\"#basic_account\").evently(app.ddoc.vendor.couchapp.evently.account);      \n    });\n\nRun this example and try signing up, and logging in and out. This code is part of the CouchApp standard library, so feel free to use it in your applications. It is also \"trivial\" to replace and extend the functionality. In a minutes, we'll start by replacing a template, and then show how you can use Evently to connect multiple widgets, to build more complex applications.\n\n## A widget is a collection of event handlers\n\nFirst lets look more closely at the account widget (click Run to see the code we're about to discuss, it will appear in the sidebar -- the example code below is just used for loading and displaying the account widget source code).\n\n    $.couch.app(function(app){\n      $(\"#account_widget_code\").evently({\n        _init : {\n          mustache : \"<pre>{{json}}</pre>\",\n          data : function() {\n            var widget = app.ddoc.vendor.couchapp.evently.account;\n            return {\n              json : JSON.stringify(widget, null, 2)\n            }\n          }\n        }\n      });      \n    });\n\nThe top level keys are the most important: `loggedIn`, `loggedOut`, `adminParty`, `signupForm`, `loginForm`, `doLogin`, `doSignup`, and `_init`. Each one of these corresponds to an event or state the system can be in. Some of them draw user interface elements, other directly trigger further events. \n\n### _init\n\nThe `_init` event is special, in that Evently will automatically trigger it when the widget is created. Here is the code for the account widget's `_init` event handler.\n\n    function() {\n      var elem = $(this);\n      $.couch.session({\n        success : function(r) {\n          var userCtx = r.userCtx;\n          if (userCtx.name) {\n            elem.trigger(\"loggedIn\", [r]);\n          } else if (userCtx.roles.indexOf(\"_admin\") != -1) {\n            elem.trigger(\"adminParty\");\n          } else {\n            elem.trigger(\"loggedOut\");\n          };\n        }\n      });\n    }\n\nThis code does one query to CouchDB, to retrieve the session information for the current user. For this we use the `$.couch.session()` function which is part of the [jquery.couch.js](/_utils/script/jquery.couch.js) library which is part of the CouchDB distribution.\n\nThe response is handled in one of three ways, depending on the user's session information. Either we trigger the `loggedIn` or `loggedOut` events, or in the special case where we detect that CouchDB's security is not properly configured, we trigger the `adminParty` event to warn the user.\n\n### loggedOut\n\nBecause most visitors start logged out, let's now turn our attention to the `loggedOut` event handler to see what will greet a new visitor:\n\n    \"loggedOut\": {\n        \"mustache\": \"<a href=\\\\\"#signup\\\\\">Signup</a> or <a href=\\\\\"#login\\\\\">Login</a>\",\n        \"selectors\": {\n          \"a[href=#login]\": {\n            \"click\": \"loginForm\"\n          },\n          \"a[href=#signup]\": {\n            \"click\": \"signupForm\"\n          }\n        }\n      }\n\nThere are two main components to this handler: `mustache` and `selectors`. `mustache` is a template file with two HTML links. `selectors` contains a set of CSS selectors with events bound to them. You can think of each selector as a nested Evently widget. In this case, clicking \"Login\" will trigger the `loginForm` event, while clicking \"Signup\" triggers the `signupForm` event.\n\n### signupForm\n\nLet's see what happens during signup. We'll skip showing the whole handler (it should be in the sidebar anyway if you clicked \"run\" earlier.)\n\nWhen the `signupForm` event is triggered, a mustache template draws the form. Then the selectors are run, assigning this function to the form's submit event:\n\n    function(e) {\n      var name = $('input[name=name]', this).val(),\n        pass = $('input[name=password]', this).val();              \n      $(this).trigger('doSignup', [name, pass]);\n      return false;\n    }\n\nThis handler is as simple as possible, all it does is use jQuery to pull the user data from the form, and send the name and password to the `doSignup` event. We could just use a function call here, but it's nice to keep our individual events as small as possible, as this makes customizing Evently widgets simpler.\n\n### doSignup\n\nHere is the `doSignup` handler:\n\n    function(e, name, pass) {\n      var elem = $(this);\n      $.couch.signup({\n        name : name\n      }, pass, {\n        success : function() {\n          elem.trigger(\"doLogin\", [name, pass]);\n        }\n      });\n    }\n\nAgain, all the complex signup logic (encrypting passwords, etc) is pushed to the [jquery.couch.js](/_utils/script/jquery.couch.js) library (via the `$.couch.signup()` call), so our application code can stay as simple as possible. When signup is complete, we trigger the `doLogin` event, so new users don't have to go through another action.\n\n### doLogin\n\nThe code for `doLogin` isn't much different, just take the name and password, and call a jquery.couch.js library function with it.\n\n    function(e, name, pass) {\n      var elem = $(this);\n      $.couch.login({\n        name : name,\n        password : pass,\n        success : function(r) {\n          elem.trigger(\"_init\")\n        }\n      });      \n    }\n\nThe last thing that `doLogin` does is trigger `_init`, so we come full circle! This time, `_init` will see that the user is logged in, and trigger the `loggedIn` event. You'll probably want to hook your application to this `loggedIn` event, to activate any features which are reserved for registered users. We'll cover linking events in a later section.\n\n## Customizing the account widget\n\nEvently widgets are built out of JSON objects, which makes it easy to replace bits and pieces of them without having to mess with the entire widget. We'll start by customizing what users see when they are logged in.\n\n    $.couch.app(function(app){\n      var customizedWidget = $.extend(true, {}, app.ddoc.vendor.couchapp.evently.account, {\n        loggedIn : {\n          mustache : '<span>Hello <strong>{{name}}</strong> you are logged in! ' +\n            '<a href=\"#logout\">Would you like to logout?</a></span>'\n        }\n      });\n      $(\"#customWelcome\").evently(customizedWidget);      \n    });\n\nTake a moment to run this example code and login to see how our custom template has replaced just one screen in the widget. The first time I did this I thought it was pretty cool. Hopefully you can think of a lot of powerful stuff you could do with it. The sky is the limit.\n\nHere's another quick one:\n\n    $.couch.app(function(app){\n      var customizedWidget = $.extend(true, {}, app.ddoc.vendor.couchapp.evently.account, {\n        loggedOut : {\n          after : \"function(){alert('Bye bye');}\"\n        }\n      });\n      $(\"#afterAlert\").evently(customizedWidget);      \n    });\n\nFor a deeper reference on what the various parts of an Evently widget are named, and how you can use them, see [the Evently docs page](#/topic/evently).\n\n## Linking two widgets\n\nFirst, lets create a basic widget. This one just has an `_init` handler and a handler called `loggedIn`. There is nothing in this widget definition that will trigger `loggedIn`, unless something else triggers it, there's no way it will run.\n\n    $(\"#link_target\").evently({\n      _init : {\n        mustache : \"<p>Not much to see here</p>\"\n      },\n      loggedIn : {\n        mustache : \"<p>loggedIn was triggered from another widget, {{name}}.</p>\",\n        data : function(e, r) {\n          return { name : r.userCtx.name };\n        }\n      }\n    });\n\nBe sure to run the above example code before the next one, otherwise there won't be anything to link to.\n\nThis next block of code demonstrates how to link two widgets together. First we create a normal account widget on the `#link_source` element, then we tell Evently to connect it to the `#link_target` element. Now whenever the `loggedIn` evenr is triggered on the source, it will be triggered on the target.\n\n    $.couch.app(function(app){\n      $(\"#link_source\").evently(app.ddoc.vendor.couchapp.evently.account);\n      // link the source to the target, for the loggedIn event\n      $.evently.connect($(\"#link_source\"), $(\"#link_target\"), [\"loggedIn\"]);\n    });\n\n## Conclusion\n\nIf you are writing a CouchApp that will have users logging and and logging out, you'd do well to use the account widget. It's customizable and linkable. And what's more, it's code that's already written.\n\nEnjoy!\n\n    ",
        "couchapp": "# Docs for $.couch.app\n\nThe simplest use of CouchApp in the browser is to get access to information about the database you are running in.\n\n    $.couch.app(function(app) {\n      $(\"#dbinfo\").evently({\n        _init : {\n          mustache : '<p>The db name is <strong>{{name}}</strong></p>',\n          data : app.db\n        }\n      });\n    });\n\nYay couchapp.\n\nThe `$.couch.app()` function also loads the current design document so that it is available for templates etc. That is how the words you are reading were loaded. This file is included in the CouchApp application library. Let's look at the design doc:\n\n    $.couch.app(function(app) {\n      $(\"#ddoc\").evently({\n        _init : {\n          mustache : '<p>Click to show the full doc source:</p><pre>{{ddoc}}</pre>',\n          data : {\n            ddoc : JSON.stringify(app.ddoc, null, 2).slice(0,100) + '...'\n          }\n        },\n        click : {\n          mustache : '<p>The full doc source (rerun to hide):</p><pre>{{ddoc}}</pre>',\n          data : {\n            ddoc : JSON.stringify(app.ddoc, null, 2)\n          }\n        }\n      });\n    });\n\n",
        "evently": "# Evently Docs\n\nEvently is an declarative framework for evented jQuery applications. You write your code as widgets made up of templates and callbacks, while Evently handles the busywork of linking them together.\n\nEvently has special handlers for CouchDB views and `_changes` feeds, and could be easily extended for other server-side frameworks.\n\n## Hello World\n\nAt it's simplest an Evently widget is a set of events connected to a single DOM element.\n\nJavaScript:\n\n    $(\"#hello\").evently({\n      _init : {\n        mustache : \"<p>Hello world</p>\",\n      },\n      click : {\n        mustache : \"<p>What a crazy world!</p>\",        \n      }\n    });\n\nYou can also do some more interesting things:\n\n    $(\"#heyjane\").evently({\n      _init : {\n        mustache : '<p>Hello <a href=\"#jane\">Jane</a>, <a href=\"#joan\">Joan</a> (pick one)</p>',\n        selectors : {\n          'a[href=#joan]' : {\n            click : 'hiJoan'\n          },\n          'a[href=#jane]' : {\n            click : 'hiJane'\n          }\n        }\n      },\n      hiJoan : {\n        mustache : '<p>Hello Joan!</p>'\n      },\n      hiJane : {\n        mustache : \"<p>Darn, it's Jane...</p>\",\n        after : function() {\n          setTimeout(function() {\n            // automatically trigger the \"janeRocks\" event after 2 seconds.\n            $(\"#heyjane\").trigger(\"janeRocks\");\n          }, 2000);\n        }\n      },\n      janeRocks : {\n        render : \"append\",\n        mustache : \"<p>Actually Jane is awesome.</p>\"\n      }\n    });\n\n\nThe imporant thing about this is that the widget is defined by an JavaScript object. This means we can save it as files on our hard drive and `couchapp` will handle saving it as a JSON object for us.\n\n[screenshot of the above code in textmate's file drawer]\n\nWhen we let CouchApp package our evently apps we get to work on them in individual files, instead of as a great big giant mess of JavaScript. This means HTML is HTML, JSON is JSON, and JavaScript is JavaScript. Yay!\n\n## Ajax Hello World\n\nLet's do a little Ajax. We'll just load the version of the CouchDB instance we happen to be serving our HTML from:\n\n    $(\"#ajax\").evently({\n      _init : {\n        mustache : '<p>Loading CouchDB server info.</p>',\n        after : function() {\n          var widget = $(this);\n          $.ajax({\n            url : '/',\n            complete : function(req) {\n              var resp = $.httpData(req, \"json\");\n              widget.trigger(\"version\", [resp]);\n            }\n          })\n        }\n      },\n      version : {\n        mustache : \"<p>Running CouchDB version {{version}}</p>\",\n        data : function(e, resp) {\n          return resp;\n        }\n      }\n    });\n\nExplain `mustache` and `data`\n\n-- triggering other events\n  -- selectors\n  -- create a doc\n\n## Evently and CouchApp together\n\nEvently makes it easy to write decoupled JavaScript code, but as the examples above show, Evently widgets can turn into a lot of JSON to look at all on one screen. Because Evently code is declarative, and each handler and callback stands on its own (instead of being wrapped in a common closure), it can be broken out into individual files.\n\nCouchApp provides a mechanism for mapping between individual files and JSON structures. In this model a directory structure is mapped to a JSON object. So if you have a directory structure like:\n\n    _init/\n      mustache.html\n      selectors/\n        form/\n          submit.js\n        input.name/\n          change.js\n        a.cancel/\n          click.txt\n    cancelled/\n      mustache.html\n      selectors/\n        a.continue/\n          click.txt\n\nIt will appear within your CouchApp design document as:\n\n    {\n      _init : {\n        mustache : \"contents of mustache.html\",\n        selectors {\n          form : {\n            submit : \"function() { ... }\"\n          },\n          \"input.name\" {\n            change : \"function() { ... }\"\n          },\n          \"a.cancel\" {\n            click : \"cancelled\"\n          }\n        }\n      },\n      cancelled : {\n        mustache : \"contents of mustache.html\",\n        selectors : {\n          \"a.continue\" : {\n            click : \"_init\"\n          }\n        }\n      }\n    }\n\nThis makes Evently and CouchApp a natural fit for each other. I swear I didn't plan this when I started writing Evently, it just turned out to be an awesome side effect of trying to stay as close to JSON as possible.\n\nIn the [account widget tutorial](#/topic/account) we see the details of the account widget. What isn't discussed much there, is how the code is edited on your filesystem.\n\nIf you are writing an Evently CouchApp widget you can edit the individual pieces on your filesystem. This has the added advantage of giving you native syntax highlighting for all the code. Instead of editing everything as JSON or JavaScript, the templates can be treated as HTML, the paths as text, etc.\n\n## Evently Queries\n\nEvently understands CouchDB in a couple of very simple ways. If you know CouchDB, you're probably familiar with its Map Reduce views. Evently lets you specify view queries in a declarative way, and even takes care of the Ajax request. All you have to do is write code to handle the returned data.\n\n-- new rows, etc\n\n-- run a query\n\n-- connect to changes\n\n-- links to example apps\n\n## Freeform Asynchronous Actions\n\nWatch out, you're dangerous! Evently allows you to make any old asyncronous action you want, with the `widget.async` member. The callback is the first argument to the `async` function. Check it out:\n\n    $(\"#async\").evently({\n      _init : {\n        mustache : \"<p>How many databases on the local host?</p><p>Answer: {{number_of_dbs}}</p><p>Other stuff: {{args}}</p><p>More: {{allArgs}}</p>\",\n        async : function(cb) {\n          var ag = Array.prototype.slice.call(arguments).map(function(a){return a.toSource ? a.toSource() : a});\n          $.couch.allDbs({\n            success : function(resp) {\n              cb(resp.length, ag);\n            }\n          })\n        },\n        data : function(count, args) {\n          return {\n            number_of_dbs : count,\n            args : JSON.stringify(args),\n            allArgs : JSON.stringify(Array.prototype.slice.call(arguments))\n          };\n        }\n      },\n      click : {\n        mustache : \"<p>What a crazy world!</p>\",\n      }\n    });",
        "docs": "# Docs for the docs system.\n\nYou are encouraged to use the couchapp docs system to write documentation for your plugins and applications. Extra bonus points because it's fun.\n\nDocs automatically make divs based on `$(\"#foo\")` pattern matching. That is, we regex the code looking for the first id we see referenced. Remember ids need to be unique on a page. For doc examples you only get one id.\n\nExample Code:\n\n    $(\"#hide_foo\").hide(\"slow\");\n\nThat's all it takes. You only get one div in each example for now. Have fun!",
        "pathbinder": "# Docs about $.pathbinder\n\nPathbinder is a tiny framework for triggering events based on paths in URL hash. For example, you might want to render one panel when the user clicks a link to `#/foo` and another when the URL hash changes to `#/bar`. If you've never used URL hashes for application state in an Ajax app before, prepare to be happy. \n\nThere are two big advantages to having the state in the URL-hash. One is that users can bookmark screens they may have reached by navigating within your app. The other is that the back button will continue to work.\n\nThe page you are on has a URL hash of `#/topic/pathbinder` right now. You can follow links to other \"pages\" within this application, and Pathbinder takes care of triggering the proper events.\n\n## A simple example\n\n    $(\"#basic_path\").html('<p><a href=\"#/foo\">click for foo</a></p>');\n    $(\"#basic_path\").bind(\"foo\", function() {\n      $(this).html(\"<p>you went to foo</p>\");\n    });\n    $(\"#basic_path\").pathbinder(\"foo\", \"/foo\");\n\nThis code sets up the `#basic_path` div with some initial content, including a link to `#/foo`. If you click the link to foo, you'll see the URL change. It is the changed URL which Pathbinder sees and uses to trigger any running code. You can experiment by manually entering the `#/foo` URL hash, instead of clicking the link, and you'll see that it also triggers the `foo` event.\n\n## Using path parameters\n\nPathbinder was inspired by the path handling in [Sammy.js](http://github.com/aq/sammy.js). Like Sammy, you can use it to pull parameters from the URL-hash. This page can be linked [using a path that has \"pathbinder\" as a parameter](#/topic/pathbinder). Let's explore how you can pull parameters out of a path.\n\n    $(\"#param_path\").html('<p><a href=\"#/foo/super\">click for super foo</a></p>');\n    $(\"#param_path\").bind(\"foo\", function(e, params) {\n      $(this).html(\"<p>you went to foo - \"+params.id+\"</p>\");\n    });\n    $(\"#param_path\").pathbinder(\"foo\", \"/foo/:id\");\n\nWhen you click the link to super foo, you'll see the param is passed through the event. You can also edit the URL to see that \"super\" is not hard coded and can be replaced with other values.\n\n## Pathbinder with Evently\n\nIt should be no suprise that Pathbinder and Evently play well together. The gist of it is that Evently looks for a key called `path` and if it finds it, uses Pathbinder to connect that event handler to the path. Let's try it out:\n\n    $(\"#evently_path\").evently({\n      _init : {\n        path : '/index',\n        mustache : '<p>the index. <a href=\"#/cowbell\">more cowbell!</a></p>'\n      },\n      cowbell : {\n        path : '/cowbell',\n        mustache : '<p>Now that is a lot of cowbell. <a href=\"#/index\">back to the index</a></p>'\n      }\n    });\n\nNote that when you use an Evently path, Evently also takes care to visit the path when the corresponding event is triggered. So running the above example code (which automatically triggers the `_init` event) will set the hash to `#/index`. If you were to trigger the `cowbell` event through non-path means, you'd see that it changes the path to `#/cowbell` anyway. \n\n### Too many widgets\n\nOne thing worth noting: there is only one URL hash for any given page, so be aware that if you have multiple widgets competing for the real-estate, they could conflict with each other. Pathbinder won't do anything when presented with a path it doesn't care about (go ahead, try out some non-sense ones on this page). \n\nThis means that if you have a few widgets all using the path, the page should still behave in a useful way. However, this breaks down if you intend people to be able to use the URL hash to link to page state. Since there can be only one URL hash, whichever action they took last will be reflected in the bookmarked URL. For this reason it makes sense to limit yourself to one path-based Evently widget per page.\n",
        "profile": "# docs for the profile evently widget\n\nThis widget makes it easy to give users a profile for your application."
    },
    "lib": {
        "atom": "// atom feed generator\n// requries E4X support.\n\nfunction f(n) {    // Format integers to have at least two digits.\n    return n < 10 ? '0' + n : n;\n}\n\nfunction rfc3339(date) {\n  return date.getUTCFullYear()   + '-' +\n    f(date.getUTCMonth() + 1) + '-' +\n    f(date.getUTCDate())      + 'T' +\n    f(date.getUTCHours())     + ':' +\n    f(date.getUTCMinutes())   + ':' +\n    f(date.getUTCSeconds())   + 'Z';\n};\n\nexports.header = function(data) {\n  var f = <feed xmlns=\"http://www.w3.org/2005/Atom\"/>;\n  f.title = data.title;\n  f.id = data.feed_id;\n  f.link.@href = data.feed_link;\n  f.link.@rel = \"self\";\n  f.generator = \"CouchApp on CouchDB\";\n  f.updated = rfc3339(data.updated);\n  return f.toXMLString().replace(/\\<\\/feed\\>/,'');\n};\n\nexports.entry = function(data) {\n  var entry = <entry/>;\n  entry.id = data.entry_id;\n  entry.title = data.title;\n  entry.content = data.content;\n  entry.content.@type = (data.content_type || 'html');\n  entry.updated = rfc3339(data.updated);\n  entry.author = <author><name>{data.author}</name></author>;\n  entry.link.@href = data.alternate;\n  entry.link.@rel = \"alternate\";\n  return entry;\n}\n",
        "cache": "exports.get = function(db, docid, setFun, getFun) {\n  db.openDoc(docid, {\n    success : function(doc) {\n      getFun(doc.cache);\n    },\n    error : function() {\n      setFun(function(cache) {\n        db.saveDoc({\n          _id : docid,\n          cache : cache\n        });\n        getFun(cache);\n      });\n    }\n  });\n};\n\nexports.clear = function(db, docid) {\n  db.openDoc(docid, {\n    success : function(doc) {\n      db.removeDoc(doc);\n    },\n    error : function() {}\n  });\n};\n",
        "docform": "// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n// use this file except in compliance with the License.  You may obtain a copy\n// of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n// License for the specific language governing permissions and limitations under\n// the License.\n\n// turn the form into deep json\n// field names like 'author-email' get turned into json like\n// {\"author\":{\"email\":\"quentin@example.com\"}}\n// acts on doc by reference, so you can safely pass non-form fields through\nfunction formToDeepJSON(form, fields, doc) {\n  form = $(form);\n  fields.forEach(function(field) {\n    var val = form.find(\"[name=\"+field+\"]\").val();\n    if (!val) {return;}\n    var parts = field.split('-');\n    var frontObj = doc, frontName = parts.shift();\n    while (parts.length > 0) {\n      frontObj[frontName] = frontObj[frontName] || {};\n      frontObj = frontObj[frontName];\n      frontName = parts.shift();\n    }\n    frontObj[frontName] = val;\n  });\n}\n\nfunction onSubmit(form, db, doc, opts) {\n  formToDeepJSON(form, opts.fields, doc);\n  if (opts.beforeSave) {opts.beforeSave(doc);}\n  db.saveDoc(localFormDoc, {\n    success : function(resp) {\n      if (opts.success) {opts.success(resp, doc);}\n    }\n  });\n};\n\nfunction applyFields(form, doc) {\n  \n};\nexports.applyFields = applyFields;\n\n// docForm applies CouchDB behavior to HTML forms.\n// todo make this a couch.app plugin\nfunction docForm(formSelector, opts) {\n  var localFormDoc = {};\n  opts = opts || {};\n  opts.fields = opts.fields || [];\n\n  // Apply the behavior\n  $(formSelector).submit(function(e) {\n\n\n    return false;\n  });\n\n  // populate form from an existing doc\n  function docToForm(doc) {\n    var form = $(formSelector);\n    // fills in forms\n    opts.fields.forEach(function(field) {\n      var parts = field.split('-');\n      var run = true, frontObj = doc, frontName = parts.shift();\n      while (frontObj && parts.length > 0) {                \n        frontObj = frontObj[frontName];\n        frontName = parts.shift();\n      }\n      if (frontObj && frontObj[frontName]) {\n        form.find(\"[name=\"+field+\"]\").val(frontObj[frontName]);              \n      }\n    });            \n  }\n\n  if (opts.id) {\n    db.openDoc(opts.id, {\n      success: function(doc) {\n        if (opts.onLoad) {opts.onLoad(doc);}\n        localFormDoc = doc;\n        docToForm(doc);\n        }});\n      } else if (opts.template) {\n        if (opts.onLoad) {opts.onLoad(opts.template);}\n        localFormDoc = opts.template;\n        docToForm(localFormDoc);\n      }\n      var instance = {\n        deleteDoc : function(opts) {\n          opts = opts || {};\n          if (confirm(\"Really delete this document?\")) {                \n            db.removeDoc(localFormDoc, opts);\n          }\n        },\n        localDoc : function() {\n          formToDeepJSON(formSelector, opts.fields, localFormDoc);\n          return localFormDoc;\n        }\n      };\n      return instance;\n    }\n\n\n\n\n",
        "list": "// Helpers for writing server-side _list functions in CouchDB\nexports.withRows = function(fun) {\n var f = function() {\n    var row = getRow();\n    return row && fun(row);\n  };\n  f.iterator = true;\n  return f;\n}\n\nexports.send = function(chunk) {\n  send(chunk + \"\\n\")\n}",
        "markdown": "//\n// showdown.js -- A javascript port of Markdown.\n//\n// Copyright (c) 2007 John Fraser.\n//\n// Original Markdown Copyright (c) 2004-2005 John Gruber\n//   <http://daringfireball.net/projects/markdown/>\n//\n// Redistributable under a BSD-style open source license.\n// See license.txt for more information.\n//\n// The full source distribution is at:\n//\n//\t\t\t\tA A L\n//\t\t\t\tT C A\n//\t\t\t\tT K B\n//\n//   <http://www.attacklab.net/>\n//\n\n//\n// Wherever possible, Showdown is a straight, line-by-line port\n// of the Perl version of Markdown.\n//\n// This is not a normal parser design; it's basically just a\n// series of string substitutions.  It's hard to read and\n// maintain this way,  but keeping Showdown close to the original\n// design makes it easier to port new features.\n//\n// More importantly, Showdown behaves like markdown.pl in most\n// edge cases.  So web applications can do client-side preview\n// in Javascript, and then build identical HTML on the server.\n//\n// This port needs the new RegExp functionality of ECMA 262,\n// 3rd Edition (i.e. Javascript 1.5).  Most modern web browsers\n// should do fine.  Even with the new regular expression features,\n// We do a lot of work to emulate Perl's regex functionality.\n// The tricky changes in this file mostly have the \"attacklab:\"\n// label.  Major or self-explanatory changes don't.\n//\n// Smart diff tools like Araxis Merge will be able to match up\n// this file with markdown.pl in a useful way.  A little tweaking\n// helps: in a copy of markdown.pl, replace \"#\" with \"//\" and\n// replace \"$text\" with \"text\".  Be sure to ignore whitespace\n// and line endings.\n//\n\n\n//\n// Showdown usage:\n//\n//   var text = \"Markdown *rocks*.\";\n//\n//   var markdown = require(\"markdown\");\n//   var html = markdown.encode(text);\n//\n//   print(html);\n//\n// Note: move the sample code to the bottom of this\n// file before uncommenting it.\n//\n\n\n//\n// Globals:\n//\n\n// Global hashes, used by various utility routines\nvar g_urls;\nvar g_titles;\nvar g_html_blocks;\n\n// Used to track when we're inside an ordered or unordered list\n// (see _ProcessListItems() for details):\nvar g_list_level = 0;\n\n\nexports.makeHtml = function(text) {\n//\n// Main function. The order in which other subs are called here is\n// essential. Link and image substitutions need to happen before\n// _EscapeSpecialCharsWithinTagAttributes(), so that any *'s or _'s in the <a>\n// and <img> tags get encoded.\n//\n\n\t// Clear the global hashes. If we don't clear these, you get conflicts\n\t// from other articles when generating a page which contains more than\n\t// one article (e.g. an index page that shows the N most recent\n\t// articles):\n\tg_urls = new Array();\n\tg_titles = new Array();\n\tg_html_blocks = new Array();\n\n\t// attacklab: Replace ~ with ~T\n\t// This lets us use tilde as an escape char to avoid md5 hashes\n\t// The choice of character is arbitray; anything that isn't\n    // magic in Markdown will work.\n\ttext = text.replace(/~/g,\"~T\");\n\n\t// attacklab: Replace $ with ~D\n\t// RegExp interprets $ as a special character\n\t// when it's in a replacement string\n\ttext = text.replace(/\\$/g,\"~D\");\n\n\t// Standardize line endings\n\ttext = text.replace(/\\r\\n/g,\"\\n\"); // DOS to Unix\n\ttext = text.replace(/\\r/g,\"\\n\"); // Mac to Unix\n\n\t// Make sure text begins and ends with a couple of newlines:\n\ttext = \"\\n\\n\" + text + \"\\n\\n\";\n\n\t// Convert all tabs to spaces.\n\ttext = _Detab(text);\n\n\t// Strip any lines consisting only of spaces and tabs.\n\t// This makes subsequent regexen easier to write, because we can\n\t// match consecutive blank lines with /\\n+/ instead of something\n\t// contorted like /[ \\t]*\\n+/ .\n\ttext = text.replace(/^[ \\t]+$/mg,\"\");\n\n\t// Turn block-level HTML blocks into hash entries\n\ttext = _HashHTMLBlocks(text);\n\n\t// Strip link definitions, store in hashes.\n\ttext = _StripLinkDefinitions(text);\n\n\ttext = _RunBlockGamut(text);\n\n\ttext = _UnescapeSpecialChars(text);\n\n\t// attacklab: Restore dollar signs\n\ttext = text.replace(/~D/g,\"$$\");\n\n\t// attacklab: Restore tildes\n\ttext = text.replace(/~T/g,\"~\");\n\treturn text;\n}\n\n\nvar _StripLinkDefinitions = function(text) {\n//\n// Strips link definitions from text, stores the URLs and titles in\n// hash references.\n//\n\n\t// Link defs are in the form: ^[id]: url \"optional title\"\n\n\t/*\n\t\tvar text = text.replace(/\n\t\t\t\t^[ ]{0,3}\\[(.+)\\]:  // id = $1  attacklab: g_tab_width - 1\n\t\t\t\t  [ \\t]*\n\t\t\t\t  \\n?\t\t\t\t// maybe *one* newline\n\t\t\t\t  [ \\t]*\n\t\t\t\t<?(\\S+?)>?\t\t\t// url = $2\n\t\t\t\t  [ \\t]*\n\t\t\t\t  \\n?\t\t\t\t// maybe one newline\n\t\t\t\t  [ \\t]*\n\t\t\t\t(?:\n\t\t\t\t  (\\n*)\t\t\t\t// any lines skipped = $3 attacklab: lookbehind removed\n\t\t\t\t  [\"(]\n\t\t\t\t  (.+?)\t\t\t\t// title = $4\n\t\t\t\t  [\")]\n\t\t\t\t  [ \\t]*\n\t\t\t\t)?\t\t\t\t\t// title is optional\n\t\t\t\t(?:\\n+|$)\n\t\t\t  /gm,\n\t\t\t  function(){...});\n\t*/\n\tvar text = text.replace(/^[ ]{0,3}\\[(.+)\\]:[ \\t]*\\n?[ \\t]*<?(\\S+?)>?[ \\t]*\\n?[ \\t]*(?:(\\n*)[\"(](.+?)[\")][ \\t]*)?(?:\\n+|\\Z)/gm,\n\t\tfunction (wholeMatch,m1,m2,m3,m4) {\n\t\t\tm1 = m1.toLowerCase();\n\t\t\tg_urls[m1] = _EncodeAmpsAndAngles(m2);  // Link IDs are case-insensitive\n\t\t\tif (m3) {\n\t\t\t\t// Oops, found blank lines, so it's not a title.\n\t\t\t\t// Put back the parenthetical statement we stole.\n\t\t\t\treturn m3+m4;\n\t\t\t} else if (m4) {\n\t\t\t\tg_titles[m1] = m4.replace(/\"/g,\"&quot;\");\n\t\t\t}\n\t\t\t\n\t\t\t// Completely remove the definition from the text\n\t\t\treturn \"\";\n\t\t}\n\t);\n\n\treturn text;\n}\n\n\nvar _HashHTMLBlocks = function(text) {\n\t// attacklab: Double up blank lines to reduce lookaround\n\ttext = text.replace(/\\n/g,\"\\n\\n\");\n\n\t// Hashify HTML blocks:\n\t// We only want to do this for block-level HTML tags, such as headers,\n\t// lists, and tables. That's because we still want to wrap <p>s around\n\t// \"paragraphs\" that are wrapped in non-block-level tags, such as anchors,\n\t// phrase emphasis, and spans. The list of tags we're looking for is\n\t// hard-coded:\n\tvar block_tags_a = \"p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del\"\n\tvar block_tags_b = \"p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math\"\n\n\t// First, look for nested blocks, e.g.:\n\t//   <div>\n\t//     <div>\n\t//     tags for inner block must be indented.\n\t//     </div>\n\t//   </div>\n\t//\n\t// The outermost tags must start at the left margin for this to match, and\n\t// the inner nested divs must be indented.\n\t// We need to do this before the next, more liberal match, because the next\n\t// match will start at the first `<div>` and stop at the first `</div>`.\n\n\t// attacklab: This regex can be expensive when it fails.\n\t/*\n\t\tvar text = text.replace(/\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t^\t\t\t\t\t// start of line  (with /m)\n\t\t\t<($block_tags_a)\t// start tag = $2\n\t\t\t\\b\t\t\t\t\t// word break\n\t\t\t\t\t\t\t\t// attacklab: hack around khtml/pcre bug...\n\t\t\t[^\\r]*?\\n\t\t\t// any number of lines, minimally matching\n\t\t\t</\\2>\t\t\t\t// the matching end tag\n\t\t\t[ \\t]*\t\t\t\t// trailing spaces/tabs\n\t\t\t(?=\\n+)\t\t\t\t// followed by a newline\n\t\t)\t\t\t\t\t\t// attacklab: there are sentinel newlines at end of document\n\t\t/gm,function(){...}};\n\t*/\n\ttext = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\\b[^\\r]*?\\n<\\/\\2>[ \\t]*(?=\\n+))/gm,hashElement);\n\n\t//\n\t// Now match more liberally, simply from `\\n<tag>` to `</tag>\\n`\n\t//\n\n\t/*\n\t\tvar text = text.replace(/\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t^\t\t\t\t\t// start of line  (with /m)\n\t\t\t<($block_tags_b)\t// start tag = $2\n\t\t\t\\b\t\t\t\t\t// word break\n\t\t\t\t\t\t\t\t// attacklab: hack around khtml/pcre bug...\n\t\t\t[^\\r]*?\t\t\t\t// any number of lines, minimally matching\n\t\t\t.*</\\2>\t\t\t\t// the matching end tag\n\t\t\t[ \\t]*\t\t\t\t// trailing spaces/tabs\n\t\t\t(?=\\n+)\t\t\t\t// followed by a newline\n\t\t)\t\t\t\t\t\t// attacklab: there are sentinel newlines at end of document\n\t\t/gm,function(){...}};\n\t*/\n\ttext = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math)\\b[^\\r]*?.*<\\/\\2>[ \\t]*(?=\\n+)\\n)/gm,hashElement);\n\n\t// Special case just for <hr />. It was easier to make a special case than\n\t// to make the other regex more complicated.  \n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t\\n\\n\t\t\t\t// Starting after a blank line\n\t\t\t[ ]{0,3}\n\t\t\t(<(hr)\t\t\t\t// start tag = $2\n\t\t\t\\b\t\t\t\t\t// word break\n\t\t\t([^<>])*?\t\t\t// \n\t\t\t\\/?>)\t\t\t\t// the matching end tag\n\t\t\t[ \\t]*\n\t\t\t(?=\\n{2,})\t\t\t// followed by a blank line\n\t\t)\n\t\t/g,hashElement);\n\t*/\n\ttext = text.replace(/(\\n[ ]{0,3}(<(hr)\\b([^<>])*?\\/?>)[ \\t]*(?=\\n{2,}))/g,hashElement);\n\n\t// Special case for standalone HTML comments:\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t\\n\\n\t\t\t\t// Starting after a blank line\n\t\t\t[ ]{0,3}\t\t\t// attacklab: g_tab_width - 1\n\t\t\t<!\n\t\t\t(--[^\\r]*?--\\s*)+\n\t\t\t>\n\t\t\t[ \\t]*\n\t\t\t(?=\\n{2,})\t\t\t// followed by a blank line\n\t\t)\n\t\t/g,hashElement);\n\t*/\n\ttext = text.replace(/(\\n\\n[ ]{0,3}<!(--[^\\r]*?--\\s*)+>[ \\t]*(?=\\n{2,}))/g,hashElement);\n\n\t// PHP and ASP-style processor instructions (<?...?> and <%...%>)\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(?:\n\t\t\t\\n\\n\t\t\t\t// Starting after a blank line\n\t\t)\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t[ ]{0,3}\t\t\t// attacklab: g_tab_width - 1\n\t\t\t(?:\n\t\t\t\t<([?%])\t\t\t// $2\n\t\t\t\t[^\\r]*?\n\t\t\t\t\\2>\n\t\t\t)\n\t\t\t[ \\t]*\n\t\t\t(?=\\n{2,})\t\t\t// followed by a blank line\n\t\t)\n\t\t/g,hashElement);\n\t*/\n\ttext = text.replace(/(?:\\n\\n)([ ]{0,3}(?:<([?%])[^\\r]*?\\2>)[ \\t]*(?=\\n{2,}))/g,hashElement);\n\n\t// attacklab: Undo double lines (see comment at top of this function)\n\ttext = text.replace(/\\n\\n/g,\"\\n\");\n\treturn text;\n}\n\nvar hashElement = function(wholeMatch,m1) {\n\tvar blockText = m1;\n\n\t// Undo double lines\n\tblockText = blockText.replace(/\\n\\n/g,\"\\n\");\n\tblockText = blockText.replace(/^\\n/,\"\");\n\t\n\t// strip trailing blank lines\n\tblockText = blockText.replace(/\\n+$/g,\"\");\n\t\n\t// Replace the element text with a marker (\"~KxK\" where x is its key)\n\tblockText = \"\\n\\n~K\" + (g_html_blocks.push(blockText)-1) + \"K\\n\\n\";\n\t\n\treturn blockText;\n};\n\nvar _RunBlockGamut = function(text) {\n//\n// These are all the transformations that form block-level\n// tags like paragraphs, headers, and list items.\n//\n\ttext = _DoHeaders(text);\n\n\t// Do Horizontal Rules:\n\tvar key = hashBlock(\"<hr />\");\n\ttext = text.replace(/^[ ]{0,2}([ ]?\\*[ ]?){3,}[ \\t]*$/gm,key);\n\ttext = text.replace(/^[ ]{0,2}([ ]?\\-[ ]?){3,}[ \\t]*$/gm,key);\n\ttext = text.replace(/^[ ]{0,2}([ ]?\\_[ ]?){3,}[ \\t]*$/gm,key);\n\n\ttext = _DoLists(text);\n\ttext = _DoCodeBlocks(text);\n\ttext = _DoBlockQuotes(text);\n\n\t// We already ran _HashHTMLBlocks() before, in Markdown(), but that\n\t// was to escape raw HTML in the original Markdown source. This time,\n\t// we're escaping the markup we've just created, so that we don't wrap\n\t// <p> tags around block-level tags.\n\ttext = _HashHTMLBlocks(text);\n\ttext = _FormParagraphs(text);\n\n\treturn text;\n}\n\n\nvar _RunSpanGamut = function(text) {\n//\n// These are all the transformations that occur *within* block-level\n// tags like paragraphs, headers, and list items.\n//\n\n\ttext = _DoCodeSpans(text);\n\ttext = _EscapeSpecialCharsWithinTagAttributes(text);\n\ttext = _EncodeBackslashEscapes(text);\n\n\t// Process anchor and image tags. Images must come first,\n\t// because ![foo][f] looks like an anchor.\n\ttext = _DoImages(text);\n\ttext = _DoAnchors(text);\n\n\t// Make links out of things like `<http://example.com/>`\n\t// Must come after _DoAnchors(), because you can use < and >\n\t// delimiters in inline links like [this](<url>).\n\ttext = _DoAutoLinks(text);\n\ttext = _EncodeAmpsAndAngles(text);\n\ttext = _DoItalicsAndBold(text);\n\n\t// Do hard breaks:\n\ttext = text.replace(/  +\\n/g,\" <br />\\n\");\n\n\treturn text;\n}\n\nvar _EscapeSpecialCharsWithinTagAttributes = function(text) {\n//\n// Within tags -- meaning between < and > -- encode [\\ ` * _] so they\n// don't conflict with their use in Markdown for code, italics and strong.\n//\n\n\t// Build a regex to find HTML tags and comments.  See Friedl's \n\t// \"Mastering Regular Expressions\", 2nd Ed., pp. 200-201.\n\tvar regex = /(<[a-z\\/!$](\"[^\"]*\"|'[^']*'|[^'\">])*>|<!(--.*?--\\s*)+>)/gi;\n\n\ttext = text.replace(regex, function(wholeMatch) {\n\t\tvar tag = wholeMatch.replace(/(.)<\\/?code>(?=.)/g,\"$1`\");\n\t\ttag = escapeCharacters(tag,\"\\\\`*_\");\n\t\treturn tag;\n\t});\n\n\treturn text;\n}\n\nvar _DoAnchors = function(text) {\n//\n// Turn Markdown link shortcuts into XHTML <a> tags.\n//\n\t//\n\t// First, handle reference-style links: [link text] [id]\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t\t// wrap whole match in $1\n\t\t\t\\[\n\t\t\t(\n\t\t\t\t(?:\n\t\t\t\t\t\\[[^\\]]*\\]\t\t// allow brackets nested one level\n\t\t\t\t\t|\n\t\t\t\t\t[^\\[]\t\t\t// or anything else\n\t\t\t\t)*\n\t\t\t)\n\t\t\t\\]\n\n\t\t\t[ ]?\t\t\t\t\t// one optional space\n\t\t\t(?:\\n[ ]*)?\t\t\t\t// one optional newline followed by spaces\n\n\t\t\t\\[\n\t\t\t(.*?)\t\t\t\t\t// id = $3\n\t\t\t\\]\n\t\t)()()()()\t\t\t\t\t// pad remaining backreferences\n\t\t/g,_DoAnchors_callback);\n\t*/\n\ttext = text.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g,writeAnchorTag);\n\n\t//\n\t// Next, inline-style links: [link text](url \"optional title\")\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t\t(\t\t\t\t\t\t// wrap whole match in $1\n\t\t\t\t\\[\n\t\t\t\t(\n\t\t\t\t\t(?:\n\t\t\t\t\t\t\\[[^\\]]*\\]\t// allow brackets nested one level\n\t\t\t\t\t|\n\t\t\t\t\t[^\\[\\]]\t\t\t// or anything else\n\t\t\t\t)\n\t\t\t)\n\t\t\t\\]\n\t\t\t\\(\t\t\t\t\t\t// literal paren\n\t\t\t[ \\t]*\n\t\t\t()\t\t\t\t\t\t// no id, so leave $3 empty\n\t\t\t<?(.*?)>?\t\t\t\t// href = $4\n\t\t\t[ \\t]*\n\t\t\t(\t\t\t\t\t\t// $5\n\t\t\t\t(['\"])\t\t\t\t// quote char = $6\n\t\t\t\t(.*?)\t\t\t\t// Title = $7\n\t\t\t\t\\6\t\t\t\t\t// matching quote\n\t\t\t\t[ \\t]*\t\t\t\t// ignore any spaces/tabs between closing quote and )\n\t\t\t)?\t\t\t\t\t\t// title is optional\n\t\t\t\\)\n\t\t)\n\t\t/g,writeAnchorTag);\n\t*/\n\ttext = text.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]\\([ \\t]*()<?(.*?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g,writeAnchorTag);\n\n\t//\n\t// Last, handle reference-style shortcuts: [link text]\n\t// These must come last in case you've also got [link test][1]\n\t// or [link test](/foo)\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t \t\t\t\t\t// wrap whole match in $1\n\t\t\t\\[\n\t\t\t([^\\[\\]]+)\t\t\t\t// link text = $2; can't contain '[' or ']'\n\t\t\t\\]\n\t\t)()()()()()\t\t\t\t\t// pad rest of backreferences\n\t\t/g, writeAnchorTag);\n\t*/\n\ttext = text.replace(/(\\[([^\\[\\]]+)\\])()()()()()/g, writeAnchorTag);\n\n\treturn text;\n}\n\nvar writeAnchorTag = function(wholeMatch,m1,m2,m3,m4,m5,m6,m7) {\n\tif (m7 == undefined) m7 = \"\";\n\tvar whole_match = m1;\n\tvar link_text   = m2;\n\tvar link_id\t = m3.toLowerCase();\n\tvar url\t\t= m4;\n\tvar title\t= m7;\n\t\n\tif (url == \"\") {\n\t\tif (link_id == \"\") {\n\t\t\t// lower-case and turn embedded newlines into spaces\n\t\t\tlink_id = link_text.toLowerCase().replace(/ ?\\n/g,\" \");\n\t\t}\n\t\turl = \"#\"+link_id;\n\t\t\n\t\tif (g_urls[link_id] != undefined) {\n\t\t\turl = g_urls[link_id];\n\t\t\tif (g_titles[link_id] != undefined) {\n\t\t\t\ttitle = g_titles[link_id];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (whole_match.search(/\\(\\s*\\)$/m)>-1) {\n\t\t\t\t// Special case for explicit empty url\n\t\t\t\turl = \"\";\n\t\t\t} else {\n\t\t\t\treturn whole_match;\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\turl = escapeCharacters(url,\"*_\");\n\tvar result = \"<a href=\\\"\" + url + \"\\\"\";\n\t\n\tif (title != \"\") {\n\t\ttitle = title.replace(/\"/g,\"&quot;\");\n\t\ttitle = escapeCharacters(title,\"*_\");\n\t\tresult +=  \" title=\\\"\" + title + \"\\\"\";\n\t}\n\t\n\tresult += \">\" + link_text + \"</a>\";\n\t\n\treturn result;\n}\n\n\nvar _DoImages = function(text) {\n//\n// Turn Markdown image shortcuts into <img> tags.\n//\n\n\t//\n\t// First, handle reference-style labeled images: ![alt text][id]\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t// wrap whole match in $1\n\t\t\t!\\[\n\t\t\t(.*?)\t\t\t\t// alt text = $2\n\t\t\t\\]\n\n\t\t\t[ ]?\t\t\t\t// one optional space\n\t\t\t(?:\\n[ ]*)?\t\t\t// one optional newline followed by spaces\n\n\t\t\t\\[\n\t\t\t(.*?)\t\t\t\t// id = $3\n\t\t\t\\]\n\t\t)()()()()\t\t\t\t// pad rest of backreferences\n\t\t/g,writeImageTag);\n\t*/\n\ttext = text.replace(/(!\\[(.*?)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g,writeImageTag);\n\n\t//\n\t// Next, handle inline images:  ![alt text](url \"optional title\")\n\t// Don't forget: encode * and _\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t// wrap whole match in $1\n\t\t\t!\\[\n\t\t\t(.*?)\t\t\t\t// alt text = $2\n\t\t\t\\]\n\t\t\t\\s?\t\t\t\t\t// One optional whitespace character\n\t\t\t\\(\t\t\t\t\t// literal paren\n\t\t\t[ \\t]*\n\t\t\t()\t\t\t\t\t// no id, so leave $3 empty\n\t\t\t<?(\\S+?)>?\t\t\t// src url = $4\n\t\t\t[ \\t]*\n\t\t\t(\t\t\t\t\t// $5\n\t\t\t\t(['\"])\t\t\t// quote char = $6\n\t\t\t\t(.*?)\t\t\t// title = $7\n\t\t\t\t\\6\t\t\t\t// matching quote\n\t\t\t\t[ \\t]*\n\t\t\t)?\t\t\t\t\t// title is optional\n\t\t\\)\n\t\t)\n\t\t/g,writeImageTag);\n\t*/\n\ttext = text.replace(/(!\\[(.*?)\\]\\s?\\([ \\t]*()<?(\\S+?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g,writeImageTag);\n\n\treturn text;\n}\n\nvar writeImageTag = function(wholeMatch,m1,m2,m3,m4,m5,m6,m7) {\n\tvar whole_match = m1;\n\tvar alt_text   = m2;\n\tvar link_id\t = m3.toLowerCase();\n\tvar url\t\t= m4;\n\tvar title\t= m7;\n\n\tif (!title) title = \"\";\n\t\n\tif (url == \"\") {\n\t\tif (link_id == \"\") {\n\t\t\t// lower-case and turn embedded newlines into spaces\n\t\t\tlink_id = alt_text.toLowerCase().replace(/ ?\\n/g,\" \");\n\t\t}\n\t\turl = \"#\"+link_id;\n\t\t\n\t\tif (g_urls[link_id] != undefined) {\n\t\t\turl = g_urls[link_id];\n\t\t\tif (g_titles[link_id] != undefined) {\n\t\t\t\ttitle = g_titles[link_id];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn whole_match;\n\t\t}\n\t}\t\n\t\n\talt_text = alt_text.replace(/\"/g,\"&quot;\");\n\turl = escapeCharacters(url,\"*_\");\n\tvar result = \"<img src=\\\"\" + url + \"\\\" alt=\\\"\" + alt_text + \"\\\"\";\n\n\t// attacklab: Markdown.pl adds empty title attributes to images.\n\t// Replicate this bug.\n\n\t//if (title != \"\") {\n\t\ttitle = title.replace(/\"/g,\"&quot;\");\n\t\ttitle = escapeCharacters(title,\"*_\");\n\t\tresult +=  \" title=\\\"\" + title + \"\\\"\";\n\t//}\n\t\n\tresult += \" />\";\n\t\n\treturn result;\n}\n\n\nvar _DoHeaders = function(text) {\n\n\t// Setext-style headers:\n\t//\tHeader 1\n\t//\t========\n\t//  \n\t//\tHeader 2\n\t//\t--------\n\t//\n\ttext = text.replace(/^(.+)[ \\t]*\\n=+[ \\t]*\\n+/gm,\n\t\tfunction(wholeMatch,m1){return hashBlock(\"<h1>\" + _RunSpanGamut(m1) + \"</h1>\");});\n\n\ttext = text.replace(/^(.+)[ \\t]*\\n-+[ \\t]*\\n+/gm,\n\t\tfunction(matchFound,m1){return hashBlock(\"<h2>\" + _RunSpanGamut(m1) + \"</h2>\");});\n\n\t// atx-style headers:\n\t//  # Header 1\n\t//  ## Header 2\n\t//  ## Header 2 with closing hashes ##\n\t//  ...\n\t//  ###### Header 6\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t\t^(\\#{1,6})\t\t\t\t// $1 = string of #'s\n\t\t\t[ \\t]*\n\t\t\t(.+?)\t\t\t\t\t// $2 = Header text\n\t\t\t[ \\t]*\n\t\t\t\\#*\t\t\t\t\t\t// optional closing #'s (not counted)\n\t\t\t\\n+\n\t\t/gm, function() {...});\n\t*/\n\n\ttext = text.replace(/^(\\#{1,6})[ \\t]*(.+?)[ \\t]*\\#*\\n+/gm,\n\t\tfunction(wholeMatch,m1,m2) {\n\t\t\tvar h_level = m1.length;\n\t\t\treturn hashBlock(\"<h\" + h_level + \">\" + _RunSpanGamut(m2) + \"</h\" + h_level + \">\");\n\t\t});\n\n\treturn text;\n}\n\n// This declaration keeps Dojo compressor from outputting garbage:\nvar _ProcessListItems;\n\nvar _DoLists = function(text) {\n//\n// Form HTML ordered (numbered) and unordered (bulleted) lists.\n//\n\n\t// attacklab: add sentinel to hack around khtml/safari bug:\n\t// http://bugs.webkit.org/show_bug.cgi?id=11231\n\ttext += \"~0\";\n\n\t// Re-usable pattern to match any entirel ul or ol list:\n\n\t/*\n\t\tvar whole_list = /\n\t\t(\t\t\t\t\t\t\t\t\t// $1 = whole list\n\t\t\t(\t\t\t\t\t\t\t\t// $2\n\t\t\t\t[ ]{0,3}\t\t\t\t\t// attacklab: g_tab_width - 1\n\t\t\t\t([*+-]|\\d+[.])\t\t\t\t// $3 = first list item marker\n\t\t\t\t[ \\t]+\n\t\t\t)\n\t\t\t[^\\r]+?\n\t\t\t(\t\t\t\t\t\t\t\t// $4\n\t\t\t\t~0\t\t\t\t\t\t\t// sentinel for workaround; should be $\n\t\t\t|\n\t\t\t\t\\n{2,}\n\t\t\t\t(?=\\S)\n\t\t\t\t(?!\t\t\t\t\t\t\t// Negative lookahead for another list item marker\n\t\t\t\t\t[ \\t]*\n\t\t\t\t\t(?:[*+-]|\\d+[.])[ \\t]+\n\t\t\t\t)\n\t\t\t)\n\t\t)/g\n\t*/\n\tvar whole_list = /^(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm;\n\n\tif (g_list_level) {\n\t\ttext = text.replace(whole_list,function(wholeMatch,m1,m2) {\n\t\t\tvar list = m1;\n\t\t\tvar list_type = (m2.search(/[*+-]/g)>-1) ? \"ul\" : \"ol\";\n\n\t\t\t// Turn double returns into triple returns, so that we can make a\n\t\t\t// paragraph for the last item in a list, if necessary:\n\t\t\tlist = list.replace(/\\n{2,}/g,\"\\n\\n\\n\");;\n\t\t\tvar result = _ProcessListItems(list);\n\t\n\t\t\t// Trim any trailing whitespace, to put the closing `</$list_type>`\n\t\t\t// up on the preceding line, to get it past the current stupid\n\t\t\t// HTML block parser. This is a hack to work around the terrible\n\t\t\t// hack that is the HTML block parser.\n\t\t\tresult = result.replace(/\\s+$/,\"\");\n\t\t\tresult = \"<\"+list_type+\">\" + result + \"</\"+list_type+\">\\n\";\n\t\t\treturn result;\n\t\t});\n\t} else {\n\t\twhole_list = /(\\n\\n|^\\n?)(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/g;\n\t\ttext = text.replace(whole_list,function(wholeMatch,m1,m2,m3) {\n\t\t\tvar runup = m1;\n\t\t\tvar list = m2;\n\n\t\t\tvar list_type = (m3.search(/[*+-]/g)>-1) ? \"ul\" : \"ol\";\n\t\t\t// Turn double returns into triple returns, so that we can make a\n\t\t\t// paragraph for the last item in a list, if necessary:\n\t\t\tvar list = list.replace(/\\n{2,}/g,\"\\n\\n\\n\");;\n\t\t\tvar result = _ProcessListItems(list);\n\t\t\tresult = runup + \"<\"+list_type+\">\\n\" + result + \"</\"+list_type+\">\\n\";\t\n\t\t\treturn result;\n\t\t});\n\t}\n\n\t// attacklab: strip sentinel\n\ttext = text.replace(/~0/,\"\");\n\n\treturn text;\n}\n\n_ProcessListItems = function(list_str) {\n//\n//  Process the contents of a single ordered or unordered list, splitting it\n//  into individual list items.\n//\n\t// The $g_list_level global keeps track of when we're inside a list.\n\t// Each time we enter a list, we increment it; when we leave a list,\n\t// we decrement. If it's zero, we're not in a list anymore.\n\t//\n\t// We do this because when we're not inside a list, we want to treat\n\t// something like this:\n\t//\n\t//    I recommend upgrading to version\n\t//    8. Oops, now this line is treated\n\t//    as a sub-list.\n\t//\n\t// As a single paragraph, despite the fact that the second line starts\n\t// with a digit-period-space sequence.\n\t//\n\t// Whereas when we're inside a list (or sub-list), that line will be\n\t// treated as the start of a sub-list. What a kludge, huh? This is\n\t// an aspect of Markdown's syntax that's hard to parse perfectly\n\t// without resorting to mind-reading. Perhaps the solution is to\n\t// change the syntax rules such that sub-lists must start with a\n\t// starting cardinal number; e.g. \"1.\" or \"a.\".\n\n\tg_list_level++;\n\n\t// trim trailing blank lines:\n\tlist_str = list_str.replace(/\\n{2,}$/,\"\\n\");\n\n\t// attacklab: add sentinel to emulate \\z\n\tlist_str += \"~0\";\n\n\t/*\n\t\tlist_str = list_str.replace(/\n\t\t\t(\\n)?\t\t\t\t\t\t\t// leading line = $1\n\t\t\t(^[ \\t]*)\t\t\t\t\t\t// leading whitespace = $2\n\t\t\t([*+-]|\\d+[.]) [ \\t]+\t\t\t// list marker = $3\n\t\t\t([^\\r]+?\t\t\t\t\t\t// list item text   = $4\n\t\t\t(\\n{1,2}))\n\t\t\t(?= \\n* (~0 | \\2 ([*+-]|\\d+[.]) [ \\t]+))\n\t\t/gm, function(){...});\n\t*/\n\tlist_str = list_str.replace(/(\\n)?(^[ \\t]*)([*+-]|\\d+[.])[ \\t]+([^\\r]+?(\\n{1,2}))(?=\\n*(~0|\\2([*+-]|\\d+[.])[ \\t]+))/gm,\n\t\tfunction(wholeMatch,m1,m2,m3,m4){\n\t\t\tvar item = m4;\n\t\t\tvar leading_line = m1;\n\t\t\tvar leading_space = m2;\n\n\t\t\tif (leading_line || (item.search(/\\n{2,}/)>-1)) {\n\t\t\t\titem = _RunBlockGamut(_Outdent(item));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Recursion for sub-lists:\n\t\t\t\titem = _DoLists(_Outdent(item));\n\t\t\t\titem = item.replace(/\\n$/,\"\"); // chomp(item)\n\t\t\t\titem = _RunSpanGamut(item);\n\t\t\t}\n\n\t\t\treturn  \"<li>\" + item + \"</li>\\n\";\n\t\t}\n\t);\n\n\t// attacklab: strip sentinel\n\tlist_str = list_str.replace(/~0/g,\"\");\n\n\tg_list_level--;\n\treturn list_str;\n}\n\n\nvar _DoCodeBlocks = function(text) {\n//\n//  Process Markdown `<pre><code>` blocks.\n//  \n\n\t/*\n\t\ttext = text.replace(text,\n\t\t\t/(?:\\n\\n|^)\n\t\t\t(\t\t\t\t\t\t\t\t// $1 = the code block -- one or more lines, starting with a space/tab\n\t\t\t\t(?:\n\t\t\t\t\t(?:[ ]{4}|\\t)\t\t\t// Lines must start with a tab or a tab-width of spaces - attacklab: g_tab_width\n\t\t\t\t\t.*\\n+\n\t\t\t\t)+\n\t\t\t)\n\t\t\t(\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))\t// attacklab: g_tab_width\n\t\t/g,function(){...});\n\t*/\n\n\t// attacklab: sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\n\ttext += \"~0\";\n\t\n\ttext = text.replace(/(?:\\n\\n|^)((?:(?:[ ]{4}|\\t).*\\n+)+)(\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))/g,\n\t\tfunction(wholeMatch,m1,m2) {\n\t\t\tvar codeblock = m1;\n\t\t\tvar nextChar = m2;\n\t\t\n\t\t\tcodeblock = _EncodeCode( _Outdent(codeblock));\n\t\t\tcodeblock = _Detab(codeblock);\n\t\t\tcodeblock = codeblock.replace(/^\\n+/g,\"\"); // trim leading newlines\n\t\t\tcodeblock = codeblock.replace(/\\n+$/g,\"\"); // trim trailing whitespace\n\n\t\t\tcodeblock = \"<pre><code>\" + codeblock + \"\\n</code></pre>\";\n\n\t\t\treturn hashBlock(codeblock) + nextChar;\n\t\t}\n\t);\n\n\t// attacklab: strip sentinel\n\ttext = text.replace(/~0/,\"\");\n\n\treturn text;\n}\n\nvar hashBlock = function(text) {\n\ttext = text.replace(/(^\\n+|\\n+$)/g,\"\");\n\treturn \"\\n\\n~K\" + (g_html_blocks.push(text)-1) + \"K\\n\\n\";\n}\n\n\nvar _DoCodeSpans = function(text) {\n//\n//   *  Backtick quotes are used for <code></code> spans.\n// \n//   *  You can use multiple backticks as the delimiters if you want to\n//\t include literal backticks in the code span. So, this input:\n//\t \n//\t\t Just type ``foo `bar` baz`` at the prompt.\n//\t \n//\t   Will translate to:\n//\t \n//\t\t <p>Just type <code>foo `bar` baz</code> at the prompt.</p>\n//\t \n//\tThere's no arbitrary limit to the number of backticks you\n//\tcan use as delimters. If you need three consecutive backticks\n//\tin your code, use four for delimiters, etc.\n//\n//  *  You can use spaces to get literal backticks at the edges:\n//\t \n//\t\t ... type `` `bar` `` ...\n//\t \n//\t   Turns to:\n//\t \n//\t\t ... type <code>`bar`</code> ...\n//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t\t(^|[^\\\\])\t\t\t\t\t// Character before opening ` can't be a backslash\n\t\t\t(`+)\t\t\t\t\t\t// $2 = Opening run of `\n\t\t\t(\t\t\t\t\t\t\t// $3 = The code block\n\t\t\t\t[^\\r]*?\n\t\t\t\t[^`]\t\t\t\t\t// attacklab: work around lack of lookbehind\n\t\t\t)\n\t\t\t\\2\t\t\t\t\t\t\t// Matching closer\n\t\t\t(?!`)\n\t\t/gm, function(){...});\n\t*/\n\n\ttext = text.replace(/(^|[^\\\\])(`+)([^\\r]*?[^`])\\2(?!`)/gm,\n\t\tfunction(wholeMatch,m1,m2,m3,m4) {\n\t\t\tvar c = m3;\n\t\t\tc = c.replace(/^([ \\t]*)/g,\"\");\t// leading whitespace\n\t\t\tc = c.replace(/[ \\t]*$/g,\"\");\t// trailing whitespace\n\t\t\tc = _EncodeCode(c);\n\t\t\treturn m1+\"<code>\"+c+\"</code>\";\n\t\t});\n\n\treturn text;\n}\n\n\nvar _EncodeCode = function(text) {\n//\n// Encode/escape certain characters inside Markdown code runs.\n// The point is that in code, these characters are literals,\n// and lose their special Markdown meanings.\n//\n\t// Encode all ampersands; HTML entities are not\n\t// entities within a Markdown code span.\n\ttext = text.replace(/&/g,\"&amp;\");\n\n\t// Do the angle bracket song and dance:\n\ttext = text.replace(/</g,\"&lt;\");\n\ttext = text.replace(/>/g,\"&gt;\");\n\n\t// Now, escape characters that are magic in Markdown:\n\ttext = escapeCharacters(text,\"\\*_{}[]\\\\\",false);\n\n// jj the line above breaks this:\n//---\n\n//* Item\n\n//   1. Subitem\n\n//            special char: *\n//---\n\n\treturn text;\n}\n\n\nvar _DoItalicsAndBold = function(text) {\n\n\t// <strong> must go first:\n\ttext = text.replace(/(\\*\\*|__)(?=\\S)([^\\r]*?\\S[*_]*)\\1/g,\n\t\t\"<strong>$2</strong>\");\n\n\ttext = text.replace(/(\\*|_)(?=\\S)([^\\r]*?\\S)\\1/g,\n\t\t\"<em>$2</em>\");\n\n\treturn text;\n}\n\n\nvar _DoBlockQuotes = function(text) {\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t\t\t// Wrap whole match in $1\n\t\t\t(\n\t\t\t\t^[ \\t]*>[ \\t]?\t\t\t// '>' at the start of a line\n\t\t\t\t.+\\n\t\t\t\t\t// rest of the first line\n\t\t\t\t(.+\\n)*\t\t\t\t\t// subsequent consecutive lines\n\t\t\t\t\\n*\t\t\t\t\t\t// blanks\n\t\t\t)+\n\t\t)\n\t\t/gm, function(){...});\n\t*/\n\n\ttext = text.replace(/((^[ \\t]*>[ \\t]?.+\\n(.+\\n)*\\n*)+)/gm,\n\t\tfunction(wholeMatch,m1) {\n\t\t\tvar bq = m1;\n\n\t\t\t// attacklab: hack around Konqueror 3.5.4 bug:\n\t\t\t// \"----------bug\".replace(/^-/g,\"\") == \"bug\"\n\n\t\t\tbq = bq.replace(/^[ \\t]*>[ \\t]?/gm,\"~0\");\t// trim one level of quoting\n\n\t\t\t// attacklab: clean up hack\n\t\t\tbq = bq.replace(/~0/g,\"\");\n\n\t\t\tbq = bq.replace(/^[ \\t]+$/gm,\"\");\t\t// trim whitespace-only lines\n\t\t\tbq = _RunBlockGamut(bq);\t\t\t\t// recurse\n\t\t\t\n\t\t\tbq = bq.replace(/(^|\\n)/g,\"$1  \");\n\t\t\t// These leading spaces screw with <pre> content, so we need to fix that:\n\t\t\tbq = bq.replace(\n\t\t\t\t\t/(\\s*<pre>[^\\r]+?<\\/pre>)/gm,\n\t\t\t\tfunction(wholeMatch,m1) {\n\t\t\t\t\tvar pre = m1;\n\t\t\t\t\t// attacklab: hack around Konqueror 3.5.4 bug:\n\t\t\t\t\tpre = pre.replace(/^  /mg,\"~0\");\n\t\t\t\t\tpre = pre.replace(/~0/g,\"\");\n\t\t\t\t\treturn pre;\n\t\t\t\t});\n\t\t\t\n\t\t\treturn hashBlock(\"<blockquote>\\n\" + bq + \"\\n</blockquote>\");\n\t\t});\n\treturn text;\n}\n\n\nvar _FormParagraphs = function(text) {\n//\n//  Params:\n//    $text - string to process with html <p> tags\n//\n\n\t// Strip leading and trailing lines:\n\ttext = text.replace(/^\\n+/g,\"\");\n\ttext = text.replace(/\\n+$/g,\"\");\n\n\tvar grafs = text.split(/\\n{2,}/g);\n\tvar grafsOut = new Array();\n\n\t//\n\t// Wrap <p> tags.\n\t//\n\tvar end = grafs.length;\n\tfor (var i=0; i<end; i++) {\n\t\tvar str = grafs[i];\n\n\t\t// if this is an HTML marker, copy it\n\t\tif (str.search(/~K(\\d+)K/g) >= 0) {\n\t\t\tgrafsOut.push(str);\n\t\t}\n\t\telse if (str.search(/\\S/) >= 0) {\n\t\t\tstr = _RunSpanGamut(str);\n\t\t\tstr = str.replace(/^([ \\t]*)/g,\"<p>\");\n\t\t\tstr += \"</p>\"\n\t\t\tgrafsOut.push(str);\n\t\t}\n\n\t}\n\n\t//\n\t// Unhashify HTML blocks\n\t//\n\tend = grafsOut.length;\n\tfor (var i=0; i<end; i++) {\n\t\t// if this is a marker for an html block...\n\t\twhile (grafsOut[i].search(/~K(\\d+)K/) >= 0) {\n\t\t\tvar blockText = g_html_blocks[RegExp.$1];\n\t\t\tblockText = blockText.replace(/\\$/g,\"$$$$\"); // Escape any dollar signs\n\t\t\tgrafsOut[i] = grafsOut[i].replace(/~K\\d+K/,blockText);\n\t\t}\n\t}\n\n\treturn grafsOut.join(\"\\n\\n\");\n}\n\n\nvar _EncodeAmpsAndAngles = function(text) {\n// Smart processing for ampersands and angle brackets that need to be encoded.\n\t\n\t// Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:\n\t//   http://bumppo.net/projects/amputator/\n\ttext = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\\w+);)/g,\"&amp;\");\n\t\n\t// Encode naked <'s\n\ttext = text.replace(/<(?![a-z\\/?\\$!])/gi,\"&lt;\");\n\t\n\treturn text;\n}\n\n\nvar _EncodeBackslashEscapes = function(text) {\n//\n//   Parameter:  String.\n//   Returns:\tThe string, with after processing the following backslash\n//\t\t\t   escape sequences.\n//\n\n\t// attacklab: The polite way to do this is with the new\n\t// escapeCharacters() function:\n\t//\n\t// \ttext = escapeCharacters(text,\"\\\\\",true);\n\t// \ttext = escapeCharacters(text,\"`*_{}[]()>#+-.!\",true);\n\t//\n\t// ...but we're sidestepping its use of the (slow) RegExp constructor\n\t// as an optimization for Firefox.  This function gets called a LOT.\n\n\ttext = text.replace(/\\\\(\\\\)/g,escapeCharacters_callback);\n\ttext = text.replace(/\\\\([`*_{}\\[\\]()>#+-.!])/g,escapeCharacters_callback);\n\treturn text;\n}\n\n\nvar _DoAutoLinks = function(text) {\n\n\ttext = text.replace(/<((https?|ftp|dict):[^'\">\\s]+)>/gi,\"<a href=\\\"$1\\\">$1</a>\");\n\n\t// Email addresses: <address@domain.foo>\n\n\t/*\n\t\ttext = text.replace(/\n\t\t\t<\n\t\t\t(?:mailto:)?\n\t\t\t(\n\t\t\t\t[-.\\w]+\n\t\t\t\t\\@\n\t\t\t\t[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+\n\t\t\t)\n\t\t\t>\n\t\t/gi, _DoAutoLinks_callback());\n\t*/\n\ttext = text.replace(/<(?:mailto:)?([-.\\w]+\\@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)>/gi,\n\t\tfunction(wholeMatch,m1) {\n\t\t\treturn _EncodeEmailAddress( _UnescapeSpecialChars(m1) );\n\t\t}\n\t);\n\n\treturn text;\n}\n\n\nvar _EncodeEmailAddress = function(addr) {\n//\n//  Input: an email address, e.g. \"foo@example.com\"\n//\n//  Output: the email address as a mailto link, with each character\n//\tof the address encoded as either a decimal or hex entity, in\n//\tthe hopes of foiling most address harvesting spam bots. E.g.:\n//\n//\t<a href=\"&#x6D;&#97;&#105;&#108;&#x74;&#111;:&#102;&#111;&#111;&#64;&#101;\n//\t   x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;\">&#102;&#111;&#111;\n//\t   &#64;&#101;x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;</a>\n//\n//  Based on a filter by Matthew Wickline, posted to the BBEdit-Talk\n//  mailing list: <http://tinyurl.com/yu7ue>\n//\n\n\t// attacklab: why can't javascript speak hex?\n\tfunction char2hex(ch) {\n\t\tvar hexDigits = '0123456789ABCDEF';\n\t\tvar dec = ch.charCodeAt(0);\n\t\treturn(hexDigits.charAt(dec>>4) + hexDigits.charAt(dec&15));\n\t}\n\n\tvar encode = [\n\t\tfunction(ch){return \"&#\"+ch.charCodeAt(0)+\";\";},\n\t\tfunction(ch){return \"&#x\"+char2hex(ch)+\";\";},\n\t\tfunction(ch){return ch;}\n\t];\n\n\taddr = \"mailto:\" + addr;\n\n\taddr = addr.replace(/./g, function(ch) {\n\t\tif (ch == \"@\") {\n\t\t   \t// this *must* be encoded. I insist.\n\t\t\tch = encode[Math.floor(Math.random()*2)](ch);\n\t\t} else if (ch !=\":\") {\n\t\t\t// leave ':' alone (to spot mailto: later)\n\t\t\tvar r = Math.random();\n\t\t\t// roughly 10% raw, 45% hex, 45% dec\n\t\t\tch =  (\n\t\t\t\t\tr > .9  ?\tencode[2](ch)   :\n\t\t\t\t\tr > .45 ?\tencode[1](ch)   :\n\t\t\t\t\t\t\t\tencode[0](ch)\n\t\t\t\t);\n\t\t}\n\t\treturn ch;\n\t});\n\n\taddr = \"<a href=\\\"\" + addr + \"\\\">\" + addr + \"</a>\";\n\taddr = addr.replace(/\">.+:/g,\"\\\">\"); // strip the mailto: from the visible part\n\n\treturn addr;\n}\n\n\nvar _UnescapeSpecialChars = function(text) {\n//\n// Swap back in all the special characters we've hidden.\n//\n\ttext = text.replace(/~E(\\d+)E/g,\n\t\tfunction(wholeMatch,m1) {\n\t\t\tvar charCodeToReplace = parseInt(m1);\n\t\t\treturn String.fromCharCode(charCodeToReplace);\n\t\t}\n\t);\n\treturn text;\n}\n\n\nvar _Outdent = function(text) {\n//\n// Remove one level of line-leading tabs or spaces\n//\n\n\t// attacklab: hack around Konqueror 3.5.4 bug:\n\t// \"----------bug\".replace(/^-/g,\"\") == \"bug\"\n\n\ttext = text.replace(/^(\\t|[ ]{1,4})/gm,\"~0\"); // attacklab: g_tab_width\n\n\t// attacklab: clean up hack\n\ttext = text.replace(/~0/g,\"\")\n\n\treturn text;\n}\n\nvar _Detab = function(text) {\n// attacklab: Detab's completely rewritten for speed.\n// In perl we could fix it by anchoring the regexp with \\G.\n// In javascript we're less fortunate.\n\n\t// expand first n-1 tabs\n\ttext = text.replace(/\\t(?=\\t)/g,\"    \"); // attacklab: g_tab_width\n\n\t// replace the nth with two sentinels\n\ttext = text.replace(/\\t/g,\"~A~B\");\n\n\t// use the sentinel to anchor our regex so it doesn't explode\n\ttext = text.replace(/~B(.+?)~A/g,\n\t\tfunction(wholeMatch,m1,m2) {\n\t\t\tvar leadingText = m1;\n\t\t\tvar numSpaces = 4 - leadingText.length % 4;  // attacklab: g_tab_width\n\n\t\t\t// there *must* be a better way to do this:\n\t\t\tfor (var i=0; i<numSpaces; i++) leadingText+=\" \";\n\n\t\t\treturn leadingText;\n\t\t}\n\t);\n\n\t// clean up sentinels\n\ttext = text.replace(/~A/g,\"    \");  // attacklab: g_tab_width\n\ttext = text.replace(/~B/g,\"\");\n\n\treturn text;\n}\n\n\n//\n//  attacklab: Utility functions\n//\n\n\nvar escapeCharacters = function(text, charsToEscape, afterBackslash) {\n\t// First we have to escape the escape characters so that\n\t// we can build a character class out of them\n\tvar regexString = \"([\" + charsToEscape.replace(/([\\[\\]\\\\])/g,\"\\\\$1\") + \"])\";\n\n\tif (afterBackslash) {\n\t\tregexString = \"\\\\\\\\\" + regexString;\n\t}\n\n\tvar regex = new RegExp(regexString,\"g\");\n\ttext = text.replace(regex,escapeCharacters_callback);\n\n\treturn text;\n}\n\n\nvar escapeCharacters_callback = function(wholeMatch,m1) {\n\tvar charCodeToEscape = m1.charCodeAt(0);\n\treturn \"~E\"+charCodeToEscape+\"E\";\n}\n\nexports.encode = exports.markdown = function (src) {\n   return exports.makeHtml(src);\n};\n\nexports.main = function (system) {\n    var command = system.args.shift();\n    if (!system.args.length) {\n        system.stdout.write(exports.markdown(system.stdin.read())).flush();\n    } else {\n        var arg;\n        while (arg = system.args.shift()) {\n            var out = system.fs.basename(arg, '.md') + '.html';\n            print(out);\n            system.fs.write(out, exports.markdown(system.fs.read(arg)));\n        }\n    }\n};\n\n\n",
        "md5": "/*\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n\n/*\n * Configurable variables. You may need to tweak these to be compatible with\n * the server-side, but the defaults work in most cases.\n */\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\nvar b64pad  = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\nvar chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nfunction hex_md5(s){ return binl2hex(core_md5(str2binl(s), s.length * chrsz));}\nfunction b64_md5(s){ return binl2b64(core_md5(str2binl(s), s.length * chrsz));}\nfunction str_md5(s){ return binl2str(core_md5(str2binl(s), s.length * chrsz));}\nfunction hex_hmac_md5(key, data) { return binl2hex(core_hmac_md5(key, data)); }\nfunction b64_hmac_md5(key, data) { return binl2b64(core_hmac_md5(key, data)); }\nfunction str_hmac_md5(key, data) { return binl2str(core_hmac_md5(key, data)); }\n\n/*\n * Perform a simple self-test to see if the VM is working\n */\nfunction md5_vm_test()\n{\n  return hex_md5(\"abc\") == \"900150983cd24fb0d6963f7d28e17f72\";\n}\n\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length\n keep\n */\nfunction core_md5(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << ((len) % 32);\n  x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n\n    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\n    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\n    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\n    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\n    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\n    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\n    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\n    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\n    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\n    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\n    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\n    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\n    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\n    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\n    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\n    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\n\n    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\n    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\n    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\n    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\n    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\n    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\n    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\n    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\n    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\n    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\n    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\n    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\n    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\n    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\n    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\n    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\n\n    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\n    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\n    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\n    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\n    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\n    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\n    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\n    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\n    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\n    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\n    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\n    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\n    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\n    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\n    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\n    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\n\n    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\n    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\n    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\n    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\n    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\n    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\n    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\n    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\n    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\n    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\n    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\n    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\n    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\n    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\n    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\n    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n  }\n  return Array(a, b, c, d);\n\n}\n\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\nfunction md5_cmn(q, a, b, x, s, t)\n{\n  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);\n}\nfunction md5_ff(a, b, c, d, x, s, t)\n{\n  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n}\nfunction md5_gg(a, b, c, d, x, s, t)\n{\n  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n}\nfunction md5_hh(a, b, c, d, x, s, t)\n{\n  return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n}\nfunction md5_ii(a, b, c, d, x, s, t)\n{\n  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n}\n\n/*\n * Calculate the HMAC-MD5, of a key and some data\n */\nfunction core_hmac_md5(key, data)\n{\n  var bkey = str2binl(key);\n  if(bkey.length > 16) bkey = core_md5(bkey, key.length * chrsz);\n\n  var ipad = Array(16), opad = Array(16);\n  for(var i = 0; i < 16; i++)\n  {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);\n  return core_md5(opad.concat(hash), 512 + 128);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction bit_rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/*\n * Convert a string to an array of little-endian words\n * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.\n keep\n */\nfunction str2binl(str)\n{\n  var bin = Array();\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < str.length * chrsz; i += chrsz)\n    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (i%32);\n  return bin;\n}\n\n/*\n * Convert an array of little-endian words to a string\n */\nfunction binl2str(bin)\n{\n  var str = \"\";\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < bin.length * 32; i += chrsz)\n    str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & mask);\n  return str;\n}\n\n/*\n * Convert an array of little-endian words to a hex string.\n keep\n */\nfunction binl2hex(binarray)\n{\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i++)\n  {\n    str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +\n           hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);\n  }\n  return str;\n}\n\n/*\n * Convert an array of little-endian words to a base-64 string\n */\nfunction binl2b64(binarray)\n{\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i += 3)\n  {\n    var triplet = (((binarray[i   >> 2] >> 8 * ( i   %4)) & 0xFF) << 16)\n                | (((binarray[i+1 >> 2] >> 8 * ((i+1)%4)) & 0xFF) << 8 )\n                |  ((binarray[i+2 >> 2] >> 8 * ((i+2)%4)) & 0xFF);\n    for(var j = 0; j < 4; j++)\n    {\n      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;\n      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);\n    }\n  }\n  return str;\n}\n\nexports.hex = hex_md5;\n",
        "path": "// from couch.js\nfunction encodeOptions(options) {\n  var buf = [];\n  if (typeof(options) == \"object\" && options !== null) {\n    for (var name in options) {\n      if (!options.hasOwnProperty(name)) {continue;}\n      var value = options[name];\n      if (name == \"key\" || name == \"startkey\" || name == \"endkey\") {\n        value = JSON.stringify(value);\n      }\n      buf.push(encodeURIComponent(name) + \"=\" + encodeURIComponent(value));\n    }\n  }\n  if (!buf.length) {\n    return \"\";\n  }\n  return \"?\" + buf.join(\"&\");\n}\n\nfunction concatArgs(array, args) {\n  for (var i=0; i < args.length; i++) {\n    array.push(args[i]);\n  };\n  return array;\n};\n\nfunction makePath(array) {\n  var options, path;\n  \n  if (typeof array[array.length - 1] != \"string\") {\n    // it's a params hash\n    options = array.pop();\n  }\n  path = array.map(function(item) {return encodeURIComponent(item)}).join('/');\n  if (options) {\n    return path + encodeOptions(options);\n  } else {\n    return path;    \n  }\n};\n\nexports.init = function(req) {\n  return {\n    asset : function() {\n      var p = req.path, parts = ['', p[0], p[1] , p[2]];\n      return makePath(concatArgs(parts, arguments));\n    },\n    show : function() {\n      var p = req.path, parts = ['', p[0], p[1] , p[2], '_show'];\n      return makePath(concatArgs(parts, arguments));\n    },\n    list : function() {\n      var p = req.path, parts = ['', p[0], p[1] , p[2], '_list'];\n      return makePath(concatArgs(parts, arguments));\n    },\n    update : function() {\n      var p = req.path, parts = ['', p[0], p[1] , p[2], '_update'];\n      return makePath(concatArgs(parts, arguments));\n    },\n    limit : function(limit) {\n      var query = req.query;\n      var l = query.limit;\n      query.limit = limit;\n      var view = req.path[req.path.length - 1];\n      var list = req.path[req.path.length - 2];\n      var link = this.list(list, view, query);\n      query.limit = l;\n      return link;\n    },\n    older : function(key) {\n      if (!typeof key == \"undefined\") return null;\n      var query = req.query;\n      query.startkey = key;\n      query.skip=1;\n      var view = req.path[req.path.length - 1];\n      var list = req.path[req.path.length - 2];\n      return this.list(list, view, query);\n    },\n    absolute : function(path) {\n      return 'http://' + req.headers.Host + path;\n    }\n  }\n};\n",
        "redirect": "exports.permanent = function(redirect) {\n  return {\n    code : 301,\n    headers : {\n      \"Location\" : redirect\n    }\n  };\n};"
    },
    "evently": {
        "README": "## Starting the Document this code challenge\n\nI need help on this code. I only have so many hours in the day. Please be liberal about patching and hacking (and sharing code!) so we can all benefit. \n\nDocs patches are deeply appreciated. For now you can just stick Markdown files in the Docs directory.\n\n# Evently\n\nThese are some vendor Evently widgets that are running on the CouchApp system.\n\n## Account\n  This is how you signup, login and logout without worry about the code.\n  Todo, we could have this work against remote APIs like that Facebook stuff or whatever.\n\n\n## Profile\n  Use this to load the local users profile for the logged in user. Useful if you're going to be posting new messages. Most applications end up customizing `profile.profileReady` to render the primary data-entry form. This gets you benefits like refreshing on login / logout, etc, automatically.\n\n\n## Docs\n  This needs to be moved to it's own app.\n  I have this vision of a docs app designed for offline editing, that involves each Markdown paragraph being it's own document, with automatic use of Bespin for code samples. Any help on this would be thanked much.\n",
        "profile": {
            "loggedIn": "function(e, r) {\n  var userCtx = r.userCtx;\n  var widget = $(this);\n  // load the profile from the user doc\n  $.couch.userDb(function(db) {\n    var userDocId = \"org.couchdb.user:\"+userCtx.name;\n    db.openDoc(userDocId, {\n      success : function(userDoc) {\n        var profile = userDoc[\"couch.app.profile\"];\n        if (profile) {\n          // we copy the name to the profile so it can be used later\n          // without publishing the entire userdoc (roles, pass, etc)\n          profile.name = userDoc.name;\n          $$(widget).profile = profile;\n          widget.trigger(\"profileReady\", [profile]);\n        } else {\n          widget.trigger(\"noProfile\", [userCtx]);\n        }\n      }\n    });\n  });\n}\n",
            "loggedOut": {
                "after": "function() {\n  $$(this).profile = null;\n};",
                "mustache": "<p>Please log in to see your profile.</p>"
            },
            "profileReady": {
                "after": "function(e, p) {\n  $$(this).profile = p;\n};",
                "data": "function(e, p) {\n  return p\n}\n",
                "mustache": "<div class=\"avatar\">\n  {{#gravatar_url}}<img src=\"{{gravatar_url}}\"/>{{/gravatar_url}}\n  <div class=\"name\">\n    {{nickname}}\n  </div>\n</div>\n<p>Hello {{nickname}}!</p>\n<div style=\"clear:left;\"></div>"
            },
            "noProfile": {
                "data": "function(e, userCtx) {\n  return userCtx;\n}",
                "mustache": "<form>\n  <p>Hello {{name}}, Please setup your user profile.</p>\n  <label for=\"nickname\">Nickname \n    <input type=\"text\" name=\"nickname\" value=\"\"></label>\n  <label for=\"email\">Email (<em>for <a href=\"http://gravatar.com\">Gravatar</a></em>)\n    <input type=\"text\" name=\"email\" value=\"\"></label>\n  <label for=\"url\">URL \n    <input type=\"text\" name=\"url\" value=\"\"></label>\n  <input type=\"submit\" value=\"Go &rarr;\">\n  <input type=\"hidden\" name=\"userCtxName\" value=\"{{name}}\" id=\"userCtxName\">\n</form>",
                "selectors": {
                    "form": {
                        "submit": "function() {\n  var md5 = $$(this).app.require(\"vendor/couchapp/lib/md5\");\n  \n  // TODO this can be cleaned up with docForm?\n  // it still needs the workflow to edit an existing profile\n  var name = $(\"input[name=userCtxName]\",this).val();\n  var newProfile = {\n    rand : Math.random().toString(), \n    nickname : $(\"input[name=nickname]\",this).val(),\n    email : $(\"input[name=email]\",this).val(),\n    url : $(\"input[name=url]\",this).val()\n  }, widget = $(this);\n\n  // setup gravatar_url\n  if (md5) {\n    newProfile.gravatar_url = 'http://www.gravatar.com/avatar/'+md5.hex(newProfile.email || newProfile.rand)+'.jpg?s=40&d=identicon';    \n  }\n\n  // store the user profile on the user account document\n  $.couch.userDb(function(db) {\n    var userDocId = \"org.couchdb.user:\"+name;\n    db.openDoc(userDocId, {\n      success : function(userDoc) {\n        userDoc[\"couch.app.profile\"] = newProfile;\n        db.saveDoc(userDoc, {\n          success : function() {\n            newProfile.name = userDoc.name;\n            $$(widget).profile = newProfile;\n            widget.trigger(\"profileReady\", [newProfile]);\n          }\n        });\n      }\n    });\n  });\n  return false;\n}"
                    }
                }
            }
        },
        "account": {
            "_init": "function() {\n  var elem = $(this);\n  $.couch.session({\n    success : function(r) {\n      var userCtx = r.userCtx;\n      if (userCtx.name) {\n        elem.trigger(\"loggedIn\", [r]);\n      } else if (userCtx.roles.indexOf(\"_admin\") != -1) {\n        elem.trigger(\"adminParty\");\n      } else {\n        elem.trigger(\"loggedOut\");\n      };\n    }\n  });\n}",
            "doLogin": "function(e, name, pass) {\n  var elem = $(this);\n  $.couch.login({\n    name : name,\n    password : pass,\n    success : function(r) {\n      elem.trigger(\"_init\")\n    }\n  });      \n}",
            "doLogout": "function() {\n  var elem = $(this);\n  $.couch.logout({\n    success : function() {\n      elem.trigger(\"_init\");\n    }\n  });\n}",
            "doSignup": "function(e, name, pass) {\n  var elem = $(this);\n  $.couch.signup({\n    name : name\n  }, pass, {\n    success : function() {\n      elem.trigger(\"doLogin\", [name, pass]);\n    }\n  });\n}",
            "adminParty": {
                "mustache": "<p><strong>Admin party, everyone is admin!</strong> Fix this in <a href=\"/_utils/index.html\">Futon</a> before proceeding.</p>"
            },
            "loggedIn": {
                "data": "function(e, r) {\n  return {\n    name : r.userCtx.name,\n    uri_name : encodeURIComponent(r.userCtx.name),\n    auth_db : encodeURIComponent(r.info.authentication_db)\n  };\n}",
                "mustache": "<span>Welcome \n<a target=\"_new\" href=\"/_utils/document.html?{{auth_db}}/org.couchdb.user%3A{{uri_name}}\">{{name}}</a>! \n<a href=\"#logout\">Logout?</a>\n</span>",
                "selectors": {
                    "a[href=#logout]": {
                        "click": [
                            "doLogout"
                        ]
                    }
                }
            },
            "loggedOut": {
                "mustache": "<a href=\"#signup\">Signup</a> or <a href=\"#login\">Login</a>",
                "selectors": {
                    "a[href=#signup]": {
                        "click": [
                            "signupForm"
                        ]
                    },
                    "a[href=#login]": {
                        "click": [
                            "loginForm"
                        ]
                    }
                }
            },
            "loginForm": {
                "after": "function() {\n  $(\"input[name=name]\", this).focus();\n}",
                "mustache": "<form>\n  <label for=\"name\">Name</label> <input type=\"text\" name=\"name\" value=\"\">\n  <label for=\"password\">Password</label> <input type=\"password\" name=\"password\" value=\"\">\n  <input type=\"submit\" value=\"Login\">\n  <a href=\"#signup\">or Signup</a>\n</form>\n",
                "selectors": {
                    "a[href=#signup]": {
                        "click": [
                            "signupForm"
                        ]
                    },
                    "form": {
                        "submit": "function(e) {\n  var name = $('input[name=name]', this).val(),\n    pass = $('input[name=password]', this).val();              \n  $(this).trigger('doLogin', [name, pass]);\n  return false;\n}"
                    }
                }
            },
            "signupForm": {
                "after": "function() {\n  $(\"input[name=name]\", this).focus();\n}",
                "mustache": "<form>\n  <label for=\"name\">Name</label> <input type=\"text\" name=\"name\" value=\"\">\n  <label for=\"password\">Password</label> <input type=\"password\" name=\"password\" value=\"\">\n  <input type=\"submit\" value=\"Signup\">\n  <a href=\"#login\">or Login</a>\n</form>\n",
                "selectors": {
                    "a[href=#login]": {
                        "click": [
                            "loginForm"
                        ]
                    },
                    "form": {
                        "submit": "function(e) {\n  var name = $('input[name=name]', this).val(),\n    pass = $('input[name=password]', this).val();              \n  $(this).trigger('doSignup', [name, pass]);\n  return false;\n}"
                    }
                }
            }
        },
        "docs": {
            "index": {
                "data": "function() {\n  var docs = $$(this).app.ddoc.vendor.couchapp.docs;\n  var dnames = [];\n  $.forIn(docs, function(d) {\n    dnames.push({\n      title: d,\n      href : \"#/topic/\"+encodeURIComponent(d)\n      });\n  });\n  return {docs:dnames};\n};",
                "path": "/",
                "mustache": "<ul>\n  {{#docs}}\n    <li><a href=\"{{{href}}}\">{{title}}</a></li>\n  {{/docs}}\n</ul>"
            },
            "topic": {
                "after": "function() {\n  var app = $$(this).app;\n  var self = $(this);\n  $(\"pre\", self).each(function() {\n    var pre = $(this);\n    var js = pre.text();\n    var r = js.match(/\\$\\(\\\"\\#([^\\\"]*)\\\"\\)/);\n    if (r) {\n      var id = r[1];\n      var code_id = 'code-'+id;\n      pre.wrap('<div id=\"'+code_id+'\"></div>');\n      $('#'+code_id).evently(app.ddoc.vendor.couchapp.evently.docs.topic.edit, app, [id]);\n    }\n  });\n};\n",
                "data": "function(e, p) {\n  var doc = $$(this).app.ddoc.vendor.couchapp.docs[p.id];\n  var converter = new Showdown.converter();\n  var html = converter.makeHtml(doc);\n  return {\n    html : html\n  };\n};",
                "mustache": "<div class=\"topic\">{{{html}}}</div>",
                "path": "/topic/:id",
                "edit": {
                    "_init": {
                        "fun": "function(e, id) {\n  var editable = $(this);\n  if ($$(editable)._init_ran) {return false;}\n  // add edit link\n  var edit = $('<a class=\"edit\" href=\"#edit\">edit code</a>');\n  editable.append(edit);\n\n  // add run box\n  var example = $('<div class=\"example\"><a class=\"run\" href=\"#'+id+'\">run <strong>#'+id+'</strong></a><div id=\"'+id+'\"><strong>#'+id+'</strong> output will be here</div></div>');  \n  var s = $(\"#sidebar\");\n  var o = s.offset();\n  example.offset({\n    left: o.left\n  });\n  example.width(s.width()*0.75);\n  editable.prepend(example);\n  $$(editable)._init_ran = true;\n  return false;\n}",
                        "selectors": {
                            "a.edit": {
                                "click": "function() {\n  var pre = $(this).prev('pre');\n  var js = pre.text();\n  var lines = js.split('\\n').length;\n  var ta = $('<textarea rows=\"'+lines+'\" class=\"code\"></textarea>');\n  ta.text(js);\n  pre.replace(ta);\n  return false;  \n};\n"
                            },
                            "a.run": {
                                "click": "function(e) {\n  try {\n    function err(y, id) {\n      $('#'+id).html(['<p>Error running #', id, \n      ' code block:</p><p><pre>',\n      (y.toSource ? y.toSource() : JSON.stringify(y)),\n      '</pre></p>'].join(''));\n    }\n    var id = e.data.args[1];\n    var example = $(\"#code-\"+id);\n    var js = $('textarea',example).val() || $('pre',example).text();\n    $('#'+id).unbind();\n    try {\n      eval(js);            \n    } catch (y) {\n      err(y, id);\n    }\n  } catch(x) {\n    err(x, id);\n  }\n  return false;\n}"
                            }
                        }
                    }
                }
            }
        }
    }
};
